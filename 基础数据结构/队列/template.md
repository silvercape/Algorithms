# 区间最值模板

## 技术说明

使用单调队列维护区间最值，分为最小值和最大值。其中区间变化的特性决定使用单调队列还是单调栈，先进先出队列，先进后出栈。
更正：区间变化不决定使用哪个，而是研究的问题决定，区间最值为队列，区间阶梯型性质（向右看齐、接雨水）用栈。

### 常见使用队列情景

#### 枚举型

对每个下标枚举其前面区间或后面区间的最值，因此可以从头到尾变量，区间按照队列方式变化

#### 滑动窗口

显然符合队列方式

## 具体实现

分为队列长度有限制和无限制，队列长度无限制（窗口长度，子序列长度）一般不使用单调队列，有限制时单调队列的使用在区间变化时有两步操作，可细分为三步。

- 入队（入队时为了维护队列单调性，先进行去尾，然后入队）

  - 去尾

    - 最小值单调队列

      - 单调递增，队头最小，为当前队列最小值

      - 去除尾部比新元素大的

      - ```cpp
         while (!q.empty() && a[q.back()] >= a[i]) {
                    q.pop_back();
        }
        ```

    - 最大值单调队列

      - 单调递减，队头最大，为当前队列最大值

      - 去除尾部比新元素小的

      - ```cpp
         while (!q.empty() && a[q.back()] <= a[i]) {
                    q.pop_back();
        }
        ```

        

  - 入队

    - 直接`push_back`

- 去头（区间变化移动，队列需要去除元素）

  - 队内信息存下标好

    - 队列的数据内容是当前窗口的最值
    - 右下标固定为 i，左下标为 i + 1 - k
    - 删头是每次窗口右移时*队列头元素*恰好是*窗口左下标对应元素*时删去
    - 删头判断时需要判断头元素对应下标，而下标好找内容，内容不好找下标
    - 存下标，两个信息都能保持

  - 判断去头

    - ```cpp
      // 去头 先去尾 再入队 一定不空
      if (q.front() < i + 1 - k) {
          q.pop_front();
      }
      ```

```cpp
for (int i = 0; i < n; i++) {
        // 去尾
        while (!q.empty() && a[q.back()] >= a[i]) {
            q.pop_back();
        }
        // 入队
        q.push_back(i);

        // 去头 先去尾 再入队 一定不空
        if (q.front() < i + 1 - k) {
            q.pop_front();
        }

        // 完成队列信息维护，接下来使用队列，输出最小值 只有窗口完全时进行输出
        if (i + 1 - k >= 0)
            printf("%d ", a[q.front()]);

}
```

